<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>WebGPU Life</title>
    </head>
    <body>
        <canvas width="512" height="512"></canvas>
        <script type="module">
            const canvas = document.querySelector("canvas");
            const GRID_SIZE = 32;

            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("No appropriate GPU Adapter found.");
            }

            const device = await adapter.requestDevice();
            const context = canvas.getContext("webgpu");
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device: device,
                format: canvasFormat,
            });

            const vertices = new Float32Array([
                -0.8, -0.8, // Triangle 1 (blue)
                0.8, -0.8,
                0.8, 0.8,
                -0.8, -0.8, // Triangle 2 (red)
                0.8, 0.8,
                -0.8, 0.8,
            ]);
            
            const vertexBuffer = device.createBuffer({
                label: "Cell vertices",
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);

            const vertexBufferLayout = {
                arrayStride: 8,
                attributes: [{
                    format: "float32x2",
                    offset: 0,
                    shaderLocation: 0,
                }],
            };

            const cellShaderModule = device.createShaderModule({
                label: "Cell shader",
                code: `
                    struct VertexInput {
                        @location(0) pos: vec2f,
                        @builtin(instance_index) instance: u32,
                    };

                    struct VertexOutput {
                        @builtin(position) pos: vec4f
                    };

                    @group(0) @binding(0) var<uniform> grid: vec2f;

                    @vertex
                    fn vertexMain(input: VertexInput) -> VertexOutput {
                        let i = f32(input.instance);
                        let cell = vec2f(i % grid.x, floor(i / grid.x));
                        let cellOffset = cell / grid * 2.0;
                        let gridPos = (input.pos + 1) / grid - 1 + cellOffset;
                        var output: VertexOutput;
                        output.pos = vec4f(gridPos, 0, 1);  // (X, Y, Z, W)
                        return output;
                    }

                    @fragment
                    fn fragmentMain() -> @location(0) vec4f {
                        return vec4f(1, 0, 0, 1); // (R, G, B, A)
                    }
                `
            });

            const cellPipeline = device.createRenderPipeline({
                label: "Cell pipeline",
                layout: "auto",
                vertex: {
                    module: cellShaderModule,
                    entryPoint: "vertexMain",
                    buffers: [vertexBufferLayout]
                },
                fragment: {
                    module: cellShaderModule,
                    entryPoint: "fragmentMain",
                    targets: [{
                        format: canvasFormat
                    }]
                }
            });

            const encoder = device.createCommandEncoder();
            const pass = encoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    loadOp: "clear",
                    clearValue: { r: 0.5, g: 0.5, b: 0.5, a: 1 },
                    storeOp: "store",
                }]
            });

            const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);
            const uniformBuffer = device.createBuffer({
                label: "Grid Uniforms",
                size: uniformArray.byteLength,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(uniformBuffer, 0 , uniformArray);

            const bindGroup = device.createBindGroup({
                label: "Cell render bind group",
                layout: cellPipeline.getBindGroupLayout(0),
                entries: [{
                    binding: 0,
                    resource: { buffer: uniformBuffer }
                }],
            });

            pass.setPipeline(cellPipeline);
            pass.setVertexBuffer(0, vertexBuffer);
            pass.setBindGroup(0, bindGroup);
            pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE);
            pass.end();

            const commandBuffer = encoder.finish();
            device.queue.submit([commandBuffer]);

        </script>
    </body>
</html>
